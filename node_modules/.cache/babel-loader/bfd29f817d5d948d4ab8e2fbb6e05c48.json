{"ast":null,"code":"var _jsxFileName = \"C:\\\\take-home-frontend\\\\src\\\\components\\\\GifExpanded.js\";\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\nimport GifButtons from '../components/GifButtons';\nimport GifPanels from '../components/GifPanels';\nimport '../stylesheets/GifExpanded.css';\n/*\r\n* Expands an Expandable Gif \r\n* Includes: \r\n*\t- Gif Buttons \r\n* \t- Gif Panels \r\n*/\n\nclass GifExpanded extends Component {\n  /*\r\n  * Calculates max width for Gif Expanded \r\n  * App.width = Screen.width * .90 \r\n  * TrendingVertical.width = 212\r\n  * max width = screen.width * .90 - 212\r\n  */\n  calculateMaxWidth() {\n    return this.props.dimensions.width * .9 - 212;\n  }\n  /*\r\n  * Giphy marginTop = 10px \r\n  * Logo Height = 70px \r\n  * Search Bar Height = 52px\r\n  * Main Content Height = 20px\r\n  * Title height = 31px \r\n  * IMG marginBottom = 20px\r\n  * GIF expanded marginBottom = 20px\r\n  */\n\n\n  calculateMaxHeight() {\n    return this.props.dimensions.height - 10 - 70 - 52 - 20 - 31 - 20 - 20;\n  }\n  /*\r\n  * Finds largest image type that is less\r\n  * than screen max width and max height\r\n  */\n\n\n  findBestImageFormat() {\n    const maxWidth = this.calculateMaxWidth();\n    const maxHeight = this.calculateMaxHeight();\n    const images = this.props.pic.images;\n    /*\r\n    * Get list of possible keys \r\n    * Remove unwanted keys \r\n    */\n\n    let keys = Object.keys(images);\n    keys.splice(keys.indexOf('fixed_height_still'), 1);\n    keys.splice(keys.indexOf('fixed_width_still'), 1);\n    keys.splice(keys.indexOf('fixed_height_small_still'), 1);\n    keys.splice(keys.indexOf('fixed_width_small_still'), 1);\n    keys.splice(keys.indexOf('downsized_still'), 1);\n    keys.splice(keys.indexOf('original_still'), 1);\n    keys.splice(keys.indexOf('480w_still'), 1);\n    /*\r\n    * Apply max height and width constraints \r\n    */\n\n    let widthToType = {};\n\n    for (let i = 0; i < keys.length; i++) {\n      if (images[keys[i]].width < maxWidth && images[keys[i]].height < maxHeight) {\n        widthToType[images[keys[i]].width] = keys[i];\n      }\n    }\n    /*\r\n    * Returns format with largest width\r\n    */\n\n\n    keys = Object.keys(widthToType).map(num => {\n      return parseInt(num, 10);\n    });\n    const bestKey = Math.max(...keys);\n    return widthToType[bestKey];\n  }\n  /*\r\n  * render img or video according format type\r\n  */\n\n\n  renderImgOrVideo(format) {\n    let title = this.props.pic.title;\n    const IMG = this.props.pic.images[format];\n    let width = IMG.width;\n    let height = IMG.height;\n    let is_img = true;\n\n    if (IMG.url === undefined) {\n      is_img = false;\n    }\n    /*\r\n    * Scale an image if it's too small \r\n    */\n\n\n    const SCALES = [2, 1.75, 1.5, 1.25];\n\n    for (let i = 0; i < SCALES.length; i++) {\n      if (width <= this.calculateMaxWidth() / SCALES[i] && height <= this.calculateMaxHeight() / SCALES[i]) {\n        width *= SCALES[i];\n        height *= SCALES[i];\n        break;\n      }\n    }\n\n    if (!is_img) {\n      const mp4 = IMG.mp4;\n      return React.createElement(\"video\", {\n        src: mp4,\n        autoPlay: true,\n        loop: true,\n        muted: true,\n        playsInline: true,\n        onError: () => {\n          this.onError = () => {};\n\n          this.src = mp4;\n        },\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 106\n        },\n        __self: this\n      });\n    } else {\n      const url = IMG.url;\n      return React.createElement(\"img\", {\n        src: url,\n        height: height,\n        width: width,\n        alt: title,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 114\n        },\n        __self: this\n      });\n    }\n  }\n\n  render() {\n    if (this.props.pic === null) {\n      return null;\n    }\n\n    const title = this.props.pic.title;\n    document.title = title;\n    const format = this.findBestImageFormat();\n    return React.createElement(\"div\", {\n      className: \"gif-expanded\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 129\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 130\n      },\n      __self: this\n    }, React.createElement(\"div\", {\n      className: \"title-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 131\n      },\n      __self: this\n    }, React.createElement(\"h1\", {\n      className: \"title GIF-TITLE\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 132\n      },\n      __self: this\n    }, title ? title : 'N/A'), React.createElement(GifButtons, {\n      pic: this.props.pic,\n      info_is_off: this.props.info_is_off,\n      handleInfoButton: this.props.handleInfoButton,\n      handleShareButton: this.props.handleShareButton,\n      handleFavoriteButton: this.props.handleFavoriteButton,\n      share_is_off: this.props.share_is_off,\n      favorites: this.props.favorites,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 133\n      },\n      __self: this\n    })), React.createElement(\"div\", {\n      className: \"asset-container\",\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 135\n      },\n      __self: this\n    }, this.renderImgOrVideo(format), React.createElement(GifPanels, {\n      format: format,\n      pic: this.props.pic,\n      share_is_off: this.props.share_is_off,\n      info_is_off: this.props.info_is_off,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 137\n      },\n      __self: this\n    }))));\n  }\n\n}\n\nexport default GifExpanded;","map":{"version":3,"sources":["C:\\take-home-frontend\\src\\components\\GifExpanded.js"],"names":["React","Component","ReactDOM","GifButtons","GifPanels","GifExpanded","calculateMaxWidth","props","dimensions","width","calculateMaxHeight","height","findBestImageFormat","maxWidth","maxHeight","images","pic","keys","Object","splice","indexOf","widthToType","i","length","map","num","parseInt","bestKey","Math","max","renderImgOrVideo","format","title","IMG","is_img","url","undefined","SCALES","mp4","onError","src","render","document","info_is_off","handleInfoButton","handleShareButton","handleFavoriteButton","share_is_off","favorites"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\r\nimport ReactDOM from 'react-dom'\r\nimport GifButtons from '../components/GifButtons';\r\nimport GifPanels from '../components/GifPanels';\r\nimport '../stylesheets/GifExpanded.css';\r\n\r\n/*\r\n* Expands an Expandable Gif \r\n* Includes: \r\n*\t- Gif Buttons \r\n* \t- Gif Panels \r\n*/\r\nclass GifExpanded extends Component {\r\n\r\n\t/*\r\n\t* Calculates max width for Gif Expanded \r\n\t* App.width = Screen.width * .90 \r\n\t* TrendingVertical.width = 212\r\n\t* max width = screen.width * .90 - 212\r\n\t*/\r\n\tcalculateMaxWidth() {\r\n\t\treturn (this.props.dimensions.width*.9) - 212; \r\n\t}\r\n\r\n\t/*\r\n\t* Giphy marginTop = 10px \r\n\t* Logo Height = 70px \r\n\t* Search Bar Height = 52px\r\n\t* Main Content Height = 20px\r\n\t* Title height = 31px \r\n\t* IMG marginBottom = 20px\r\n\t* GIF expanded marginBottom = 20px\r\n\t*/\r\n\tcalculateMaxHeight() {\r\n\t\treturn this.props.dimensions.height - 10 - 70 - 52 - 20 - 31- 20 - 20;\r\n\t}\r\n\r\n\t/*\r\n\t* Finds largest image type that is less\r\n\t* than screen max width and max height\r\n\t*/\r\n\tfindBestImageFormat() {\r\n\t\tconst maxWidth = this.calculateMaxWidth(); \r\n\t\tconst maxHeight = this.calculateMaxHeight(); \r\n\t\tconst {images} = this.props.pic; \r\n\r\n\t\t/*\r\n\t\t* Get list of possible keys \r\n\t\t* Remove unwanted keys \r\n\t\t*/\r\n\t\tlet keys = Object.keys(images);\r\n\t\tkeys.splice( keys.indexOf('fixed_height_still'), 1 );\r\n\t\tkeys.splice( keys.indexOf('fixed_width_still'), 1 );\r\n\t\tkeys.splice( keys.indexOf('fixed_height_small_still'), 1 );\r\n\t\tkeys.splice( keys.indexOf('fixed_width_small_still'), 1 );\r\n\t\tkeys.splice( keys.indexOf('downsized_still'), 1 );\r\n\t\tkeys.splice( keys.indexOf('original_still'), 1 );\r\n\t\tkeys.splice( keys.indexOf('480w_still'), 1 );\r\n\r\n\t\t/*\r\n\t\t* Apply max height and width constraints \r\n\t\t*/\r\n\t\tlet widthToType = {}; \r\n\t\tfor(let i = 0; i < keys.length; i++) {\r\n\t\t\tif ((images[keys[i]].width < maxWidth) && (images[keys[i]].height < maxHeight)) {\r\n\t\t\t\twidthToType[images[keys[i]].width] = keys[i];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t* Returns format with largest width\r\n\t\t*/\r\n\t\tkeys = Object.keys(widthToType).map((num) =>{return parseInt(num, 10)});\r\n\t\tconst bestKey = Math.max(...keys);\r\n\t\treturn widthToType[bestKey];\r\n\t}\r\n\r\n\t/*\r\n\t* render img or video according format type\r\n\t*/\r\n\trenderImgOrVideo(format) {\r\n\t\tlet {title} = this.props.pic;\r\n\t\tconst IMG = this.props.pic.images[format];\r\n\t\tlet {width} = IMG;\r\n\t\tlet {height} = IMG;\r\n\t\tlet is_img = true;\r\n\t\tif (IMG.url === undefined) {\r\n\t\t\tis_img = false;\r\n\t\t}\r\n\r\n\t\t/*\r\n\t\t* Scale an image if it's too small \r\n\t\t*/\r\n\t\tconst SCALES = [2,1.75, 1.5,1.25];\r\n\t\tfor (let i = 0; i < SCALES.length; i++) { \r\n\t\t\tif ((width <= this.calculateMaxWidth()/SCALES[i]) && (height <= this.calculateMaxHeight()/SCALES[i])) {\r\n\t\t\t\twidth *= SCALES[i];\r\n\t\t\t\theight *= SCALES[i];\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (!is_img) {\r\n\t\t\tconst {mp4} = IMG;\r\n\t\t\treturn (\r\n\t\t\t\t<video src={mp4}\r\n\t\t\t\tautoPlay loop muted playsInline \r\n\t\t\t\tonError={()=>{this.onError=()=>{}; this.src=mp4;}}>\r\n            \t</video>\r\n\t\t\t); \r\n\t\t} else {\r\n\t\t\tconst {url} = IMG; \r\n\t\t\treturn (\r\n\t\t\t\t<img src={url} height={height} width={width} alt={title}/>\r\n\t\t\t); \r\n\t\t} \r\n\t}\r\n\r\n\t\r\n\trender() {\r\n\t\tif (this.props.pic === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tconst {title} = this.props.pic;\r\n\t\tdocument.title = title;\r\n\t\tconst format = this.findBestImageFormat();\r\n\r\n\t\treturn (\r\n\t\t\t<div className=\"gif-expanded\">\r\n\t\t\t\t<div>\r\n\t\t\t\t\t<div className=\"title-container\">\r\n\t\t\t\t\t\t<h1 className=\"title GIF-TITLE\">{(title ? title : 'N/A')}</h1>\r\n\t\t\t\t\t\t<GifButtons pic={this.props.pic} info_is_off={this.props.info_is_off} handleInfoButton={this.props.handleInfoButton} handleShareButton={this.props.handleShareButton} handleFavoriteButton={this.props.handleFavoriteButton} share_is_off={this.props.share_is_off} favorites={this.props.favorites}/>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t\t<div className=\"asset-container\">\r\n\t\t\t\t\t\t{this.renderImgOrVideo(format)}\t\r\n\t\t\t\t\t\t<GifPanels format={format} pic={this.props.pic} share_is_off={this.props.share_is_off} info_is_off={this.props.info_is_off}/>\r\n\t\t\t\t\t</div>\r\n\t\t\t\t</div>\r\n\t\t\t</div>\r\n\t\t);\r\n\t}\r\n}\r\n\r\nexport default GifExpanded;\r\n"]},"metadata":{},"sourceType":"module"}